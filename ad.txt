//Table.h
 
#pragma once
#include <string>
class Table
{
        int *tab; //tablica dynamiczna // jedyne prywatne pole
public:
    int cnt; //ilosc elementow w tablicy
    Table(); //konstruktor
    void addValueToTable(int index, int value);
    //....
    //....
}
 
 
 
// Table.cpp
 
 
 
void Table::addValueToTable(int index, int value) //dodaj do tablicy
{
    if(index>cnt||index<0) // zabezpieczenie przed nieprawidlowym indeksem
    {
        std::cout<<"\nNieprawidlowy index. Indeksujemy od 0.\n";
        return;
    }
    int *NewTab = new int[cnt+1]; //nowa tablica
    for(int i=0;i<index;i++) // kopiuje wartosci przed indeksem
        NewTab[i]=tab[i];
    NewTab[index]=value; //na index wstawiam zadana wartosc
    for(int i=index+1;i<cnt+1;++i) // i kopiuje reszte
        NewTab[i]=tab[i-1];
    delete[] tab; //zwalniam pamiec
    ++cnt; // zwiekszam licznik
    tab=NewTab; // przypisuje wskaznik na nowa tablice z przekazana wartoscia
}
 
 
 
//pomiary.h
 
 
 
class pomiary
{
    Table myTab;
    List myList;
    Heap myHeap;
    BST myBST;
    static const int pktypomiar = 100; //zmienna globalna okreslajaca rozdzielczosc pomiarow
    static const int powtorzenia = 10; //ile razy dokonac testow
    double czas;
    double pomiar[pktypomiar];
    //...
    //...
}
 
 
//pomiary.cpp
 
 
 
static std::fstream plik;
static std::random_device rd;
static std::mt19937 gen(rd());
static std::uniform_int_distribution<> dist(1, 1000000);
static double PCFreq = 0.0;
static __int64 CounterStart = 0;
 
void pomiary::StartCounter()
{
    LARGE_INTEGER li;
    PCFreq = double(li.QuadPart)/1000000000000.0;
    QueryPerformanceCounter(&li);
    CounterStart = li.QuadPart;
}
 
double pomiary::GetCounter()
{
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return double(li.QuadPart-CounterStart)/PCFreq;
}
 
//
void pomiary::addsmalltotablerandom()
{
    int wielkoscstruktury=200; // zmienna mówiaca co ile elementow ma dokonac pomiaru czasu
    for(int i=0;i<pktypomiar;++i)
        pomiar[pktypomiar]=0.0; //zerowanie tablicy pomiarow
    plik.open("TableAddSmallToRandom.txt" , std::ios::out); //otworzenie pliku
    if(plik.good())
    {
        for(int k=0;k<powtorzenia;++k)
        {
            for (int i=0;i<pktypomiar;++i)
            {
                for(int j=0;j<wielkoscstruktury;++j)
                {
                    myTab.generateTable((i+1)*wielkoscstruktury,nullptr,100);
                    StartCounter(); //zacznij mierzyc czas
                    myTab.addValueToTable(dist(gen)%myTab.cnt, (dist(gen)%200)-100);
                    czas=GetCounter();// skoncz mierzyc czas
                    pomiar[i]= pomiar[i]+czas; // dodaj do odpowiedniego pola w tablicy pomiarow
                    myTab.clearTable(); //wyczysc tablice
                }
            }
        }
        for(int i=0;i<pktypomiar;++i)
            plik<<(i+1)*wielkoscstruktury<<" "<< pomiar[i]/powtorzenia<<'\n'; // zapisz je w pliku, pamietajac o tym, ze testy byly przeprowadzane stukrotnie
    }
    plik.close(); //zamknij plik
}
 